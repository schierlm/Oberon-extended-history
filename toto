Sources/BootLoad.Mod:    VAR i, data, crc: INTEGER;
Sources/BootLoad.Mod:    REPEAT SPIIdle(1); SYSTEM.GET(spiData, data) UNTIL data = 255; (*flush while unselected*)
Sources/BootLoad.Mod:    REPEAT SPI(255); SYSTEM.GET(spiData, data) UNTIL data = 255; (*flush while selected*)
Sources/BootLoad.Mod:    REPEAT SPI(255); SYSTEM.GET(spiData, data); DEC(i) UNTIL (data < 80H) OR (i = 0)
Sources/BootLoad.Mod:    VAR res, data: INTEGER;
Sources/BootLoad.Mod:    VAR data: INTEGER;
Sources/BootLoad.Mod:    SYSTEM.GET(spiData, data); SPI(-1);
Sources/BootLoad.Mod:    IF (data # 0) OR ~SYSTEM.BIT(spiData, 6) THEN n := n * 512 END ;  (*non-SDHC card*)
Sources/BootLoad.Mod:    VAR i, data: INTEGER;
Sources/BootLoad.Mod:    i := 0; (*wait for start data marker*)
Sources/BootLoad.Mod:    REPEAT SPI(-1); SYSTEM.GET(spiData, data); INC(i) UNTIL data = 254;
Sources/BootLoad.Mod:      SYSTEM.GET(spiData, data); SYSTEM.PUT(dst, data); INC(dst, 4)
Sources/BootLoad.Mod:    swi = -60; led = -60; data = -56; stat = -52;
Sources/BootLoad.Mod:      SYSTEM.GET(data, y); z := ROR(z+y, 8)
Sources/BootLoadDisk.Mod:    VAR i, data, crc: INTEGER;
Sources/BootLoadDisk.Mod:    REPEAT SPIIdle(1); SYSTEM.GET(spiData, data) UNTIL data = 255; (*flush while unselected*)
Sources/BootLoadDisk.Mod:    REPEAT SPI(255); SYSTEM.GET(spiData, data) UNTIL data = 255; (*flush while selected*)
Sources/BootLoadDisk.Mod:    REPEAT SPI(255); SYSTEM.GET(spiData, data); DEC(i) UNTIL (data < 80H) OR (i = 0)
Sources/BootLoadDisk.Mod:    VAR res, data: INTEGER;
Sources/BootLoadDisk.Mod:    VAR data: INTEGER;
Sources/BootLoadDisk.Mod:    SYSTEM.GET(spiData, data); SPI(-1);
Sources/BootLoadDisk.Mod:    IF (data # 0) OR ~SYSTEM.BIT(spiData, 6) THEN n := n * 512 END ;  (*non-SDHC card*)
Sources/BootLoadDisk.Mod:    VAR i, data: INTEGER;
Sources/BootLoadDisk.Mod:    i := 0; (*wait for start data marker*)
Sources/BootLoadDisk.Mod:    REPEAT SPI(-1); SYSTEM.GET(spiData, data); INC(i) UNTIL data = 254;
Sources/BootLoadDisk.Mod:      SYSTEM.GET(spiData, data); SYSTEM.PUT(dst, data); INC(dst, 4); INC(i, 4)
Sources/Clipboard.Mod:  CONST control = -24; data = -20;
Sources/Clipboard.Mod:      SYSTEM.PUT(data, ch);
Sources/Clipboard.Mod:          SYSTEM.GET(data, ch);
Sources/Disk.Mod:    data: INTEGER; (*SPI data in*)
Sources/Disk.Mod:      SYSTEM.GET(spiData, data)
Sources/Disk.Mod:    SYSTEM.GET(spiData, data)
Sources/Disk.Mod:    REPEAT SPIIdle(1) UNTIL data = 255; (*flush while unselected*)
Sources/Disk.Mod:    REPEAT SPI(255) UNTIL data = 255; (*flush while selected*)
Sources/Disk.Mod:    REPEAT SPI(255); DEC(i) UNTIL (data < 80H) OR (i = 0)
Sources/Disk.Mod:    VAR data: INTEGER;
Sources/Disk.Mod:    SYSTEM.GET(spiData, data); SPI(-1);
Sources/Disk.Mod:    IF (data # 0) OR ~SYSTEM.BIT(spiData, 6) THEN n := n * 512 END ;  (*non-SDHC card*)
Sources/Disk.Mod:  BEGIN SDShift(src); SPICmd(17, src); ASSERT(data = 0); (*CMD17 read one block*)
Sources/Disk.Mod:    i := 0; (*wait for start data marker*)
Sources/Disk.Mod:    REPEAT SPI(-1); INC(i) UNTIL data = 254;
Sources/Disk.Mod:      SYSTEM.GET(spiData, data); SYSTEM.PUT(dst, data); INC(dst, 4)
Sources/Disk.Mod:  BEGIN SDShift(dst); SPICmd(24, dst); ASSERT(data = 0); (*CMD24 write one block*)
Sources/Disk.Mod:    SPI(254); (*write start data marker*)
Sources/Disk.Mod:    REPEAT SPI(-1); INC(i); UNTIL (data MOD 32 = 5) OR (i = 10000);
Sources/Disk.Mod:    ASSERT(data MOD 32 = 5); SPIIdle(1) (*deselect card*)
Sources/Files.Mod:        data: FileDir.DataSector
Sources/Files.Mod:          F := SYSTEM.VAL(FileDir.FileHd, SYSTEM.ADR(buf.data));
Sources/Files.Mod:          Disk.GetSector(header, buf.data); ASSERT(F.mark = FileDir.HeaderMark);
Sources/Files.Mod:      F := SYSTEM.VAL(FileDir.FileHd, SYSTEM.ADR(buf.data));
Sources/Files.Mod:    Disk.GetSector(sec, buf.data);
Sources/Files.Mod:        UpdateHeader(f, SYSTEM.VAL(FileDir.FileHeader, buf.data)); f.modH := FALSE
Sources/Files.Mod:    Disk.PutSector(secadr, buf.data); buf.mod := FALSE
Sources/Files.Mod:    IF r.bpos < r.buf.lim THEN x := r.buf.data[r.bpos]; INC(r.bpos)
Sources/Files.Mod:      x := r.buf.data[0]; r.bpos := 1
Sources/Files.Mod:    IF r.bpos < r.buf.lim THEN ch := CHR(r.buf.data[r.bpos]); INC(r.bpos)
Sources/Files.Mod:      ch := CHR(r.buf.data[0]); r.bpos := 1
Sources/Files.Mod:    r.buf.data[r.bpos] := x; INC(r.bpos); r.buf.mod := TRUE
Sources/Files.Mod:    r.buf.data[r.bpos] := ORD(ch); INC(r.bpos); r.buf.mod := TRUE
Sources/Kernel.Mod:        IF offadr = 0 THEN q := p;  (*mark elements in data structure with root p*)
Sources/Modules.Mod:      res = dynptrs: static module data referenced by pointer variables in dynamically allocated objects;
Sources/Modules.Mod:      res = statptrs: static module data referenced by global pointer variables;
Sources/Net.Mod:  PROCEDURE Send(t: BYTE; L: INTEGER; data: ARRAY OF CHAR);
Sources/Net.Mod:  BEGIN head0.typ := t; head0.len := L; SCC.SendPacket(head0, data)
Sources/ORB.Mod:  (*Definition of data types Object and Type, which together form the data structure
Sources/ORB.Mod:  (*initialize universe with data types and in-line procedures;
Sources/ORP.Mod:    ORB for definition of data structures and for handling import and export, and
Sources/ORP.Mod:    ORG to produce binary code. ORP performs type checking and data allocation.
Sources/ORP.Mod:    dc: LONGINT;    (*data counter*)
Sources/ORTool.Mod:    VAR class, i, n, key, size, adr, data, code: INTEGER;
Sources/ORTool.Mod:        Texts.WriteString(W, "data"); Files.ReadInt(R, data); Texts.WriteInt(W, data, 6); Texts.WriteLn(W);
Sources/ORTool.Mod:        WHILE i < n DO Files.ReadInt(R, data); Texts.WriteHex(W, data); INC(i) END ;
Sources/ORTool.Mod:        WHILE name[0] # 0X DO Files.ReadInt(R, data); Files.ReadString(R, name) END ;  (*commands*)
Sources/ORTool.Mod:        Files.ReadInt(R, data);
Sources/ORTool.Mod:        WHILE data >= 0 DO Files.ReadInt(R, data) END ;  (*pointer references*)
Sources/ORTool.Mod:        Files.ReadInt(R, data);
Sources/ORTool.Mod:        WHILE data >= 0 DO Files.ReadInt(R, data) END ;  (*procedure variable references*)
Sources/ORTool.Mod:          Files.ReadInt(R, data);  (*inst*)
Sources/ORTool.Mod:          adr := adr - (data MOD 4000H)*4
Sources/ORTool.Mod:          Files.ReadInt(R, data);  (*inst*)
Sources/ORTool.Mod:          adr := adr - (data MOD 10000H)*4
Sources/ORTool.Mod:          Files.ReadInt(R, data); Texts.WriteInt(W, i, 4); Texts.Write(W, TAB); Texts.WriteHex(W, data);
Sources/ORTool.Mod:          IF (nofP >= 0) & (i = fixP[nofP]) THEN opcode(data, TRUE, FALSE); DEC(nofP)
Sources/ORTool.Mod:          ELSIF (nofD >= 0) & (i = fixD[nofD]) THEN opcode(data, FALSE, TRUE); DEC(nofD)
Sources/ORTool.Mod:          ELSE opcode(data, FALSE, FALSE)
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "fixP = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "fixD = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "fixT = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "fixM = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "entry = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:        Files.ReadInt(R, data); Texts.WriteString(W, "final = "); Texts.WriteInt(W, data, 8); Texts.WriteLn(W);
Sources/ORTool.Mod:      adr, data: INTEGER;
Sources/ORTool.Mod:           SYSTEM.GET(adr, data); Texts.WriteInt(W, adr, 4); Texts.Write(W, TAB); Texts.WriteHex(W, data);
Sources/ORTool.Mod:           Texts.Write(W, TAB); opcode(data, FALSE, FALSE); Texts.WriteLn(W); INC(adr, 4)
Sources/ORX.Mod:    VAR n, data: INTEGER; ch: CHAR; b: BYTE;               (*codelen in words, entry in bytes*)
Sources/ORX.Mod:  BEGIN F := Files.Base(R); Files.ReadString(R, name); Files.ReadInt(R, data); (*key*)
Sources/ORX.Mod:    Files.ReadByte(R, b); (*version*) Files.ReadInt(R, data); (*size*)
Sources/ORX.Mod:    WHILE ~R.eof & (name[0] # 0X) DO Files.ReadInt(R, data); (*key*) Files.ReadString(R, name) END ;
Sources/ORX.Mod:    WHILE ~R.eof & (n < codelen) DO Files.ReadInt(R, data); write(R1, data); INC(n) END ; (*write code*)
Sources/ORX.Mod:    WHILE ~R.eof & (name[0] # 0X) DO Files.ReadInt(R, data); Files.ReadString(R, name) END ; (*commands*)
Sources/ORX.Mod:    Files.ReadInt(R, data);
Sources/ORX.Mod:    WHILE ~R.eof & (data >= 0) DO Files.ReadInt(R, data) END ; (*pointer references*)
Sources/ORX.Mod:    Files.ReadInt(R, data);
Sources/ORX.Mod:    WHILE ~R.eof & (data >= 0) DO Files.ReadInt(R, data) END ; (*procedure variable references*)
Sources/ORX.Mod:    Files.ReadInt(R, data); (*fixorgP*) Files.ReadInt(R, data); (*fixorgD*)
Sources/ORX.Mod:    Files.ReadInt(R, data); (*fixorgT*) Files.ReadInt(R, data); (*fixorgM*)
Sources/ORX.Mod:    Files.ReadInt(R, entry); (*body*) Files.ReadInt(R, data); (*final*)
Sources/Oberon0.Mod:    VAR m, n, adr, data: INTEGER;
Sources/Oberon0.Mod:      REPEAT SYSTEM.GET(adr, data); INC(adr, 4); RS232.SendHex(data); DEC(m) UNTIL m = 0
Sources/Oberon0.Mod:    VAR n, data: INTEGER; ch: CHAR; b: BYTE;               (*codelen in words, entry in bytes*)
Sources/Oberon0.Mod:  BEGIN Files.Set(R, F, 0); Files.ReadString(R, name); Files.ReadInt(R, data); (*key*)
Sources/Oberon0.Mod:    Files.ReadByte(R, b); (*version*) Files.ReadInt(R, data); (*size*)
Sources/Oberon0.Mod:    WHILE name[0] # 0X DO Files.ReadInt(R, data); (*key*) Files.ReadString(R, name) END ;
Sources/Oberon0.Mod:      WHILE n < codelen DO Files.ReadInt(R, data); code[n] := data; INC(n) END ; (*program code*)
Sources/Oberon0.Mod:      WHILE name[0] # 0X DO Files.ReadInt(R, data); Files.ReadString(R, name) END ; (*commands*)
Sources/Oberon0.Mod:      Files.ReadInt(R, data);
Sources/Oberon0.Mod:      WHILE data >= 0 DO Files.ReadInt(R, data) END ; (*pointer references*)
Sources/Oberon0.Mod:      Files.ReadInt(R, data);
Sources/Oberon0.Mod:      WHILE data >= 0 DO Files.ReadInt(R, data) END ; (*procedure variable references*)
Sources/Oberon0.Mod:      Files.ReadInt(R, data); (*fixorgP*) Files.ReadInt(R, data); (*fixorgD*)
Sources/Oberon0.Mod:      Files.ReadInt(R, data); (*fixorgT*) Files.ReadInt(R, data); (*fixorgM*)
Sources/Oberon0.Mod:      Files.ReadInt(R, entry); (*body*) Files.ReadInt(R, data); (*final*)
Sources/PCLink1.Mod:  CONST data = -56; stat = -52;
Sources/PCLink1.Mod:    SYSTEM.GET(data, x)
Sources/PCLink1.Mod:    SYSTEM.PUT(data, x)
Sources/PIO.Mod:  D0  =  PIC B7  data out
Sources/PIO.Mod:  D2  =  PIC A4  data in *)
Sources/RS232.Mod:  CONST data = -56; stat = -52;
Sources/RS232.Mod:    SYSTEM.PUT(data, x)
Sources/RS232.Mod:    SYSTEM.GET(data, x)
Sources/SCC.Mod:      len*: INTEGER (*of data following header*)
Sources/SCC.Mod:      rcvd := ODD(status DIV 40H) OR ~ODD(fifoStatus) (*RX_DR (data ready) or RX FIFO not empty*)
Sources/System.Mod:          ELSIF ref = Modules.dynptrs THEN Texts.WriteString(W, "  static module data of "); Texts.WriteString(W, mod.name);
Sources/System.Mod:          ELSIF ref = Modules.statptrs THEN Texts.WriteString(W, "  static module data of "); Texts.WriteString(W, mod.name);
Sources/Tools.Mod:    VAR m, n, adr, data: INTEGER;
Sources/Tools.Mod:        REPEAT SYSTEM.GET(adr, data); INC(adr, 4); Texts.WriteHex(W, data); DEC(m)
